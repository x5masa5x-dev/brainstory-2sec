<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Brain Story 2sec</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=DM+Mono:wght@400;500&family=DM+Sans:wght@400;500;700&family=Playfair+Display:ital,wght@0,700;1,600&family=Noto+Serif+JP:wght@500;700&display=swap" rel="stylesheet">
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  html { height: 100%; overflow: hidden; }
  body { background: #0d0d1a; font-family: 'DM Sans', sans-serif; height: 100%; overflow: hidden; -webkit-overflow-scrolling: touch; }
  button, textarea, input { font-family: inherit; -webkit-appearance: none; }
  textarea:focus, button:focus, input:focus { outline: none; }
  /* Prevent Safari from scrolling the page when focusing input */
  textarea { font-size: 16px !important; }
  @keyframes slideUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
  @keyframes breathe { 0%,100% { opacity: 0.4; } 50% { opacity: 0.8; } }
  @keyframes pulse { 0%,100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.6; transform: scale(1.05); } }
  ::-webkit-scrollbar { width: 4px; }
  ::-webkit-scrollbar-track { background: transparent; }
  ::-webkit-scrollbar-thumb { background: #2a2a44; border-radius: 2px; }
  #root { height: 100%; }
</style>
</head>
<body>
<div id="root"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.9/babel.min.js"></script>
<script type="text/babel">
const { useState, useRef, useEffect, useCallback } = React;

const SCENARIOS = [
  {
    id: "rainy_morning", title: "é›¨ã®æœ", genre: "ä»•äº‹",
    setting: "ã‚ãªãŸã¯è£½é€ æ¥­ã®ç­é•·ã€‚ä»Šæ—¥ã¯é‡è¦ãªå–å¼•å…ˆãŒå·¥å ´è¦‹å­¦ã«æ¥ã‚‹æ—¥ã€‚ã ãŒæ˜¨æ—¥ã€ãƒ©ã‚¤ãƒ³ã®ä¸€ã¤ã§åŸå› ä¸æ˜ã®ä¸è‰¯å“ãŒå‡ºãŸã€‚ã¾ã èª°ã«ã‚‚å ±å‘Šã—ã¦ã„ãªã„ã€‚æœ6æ™‚ã€ç›®ãŒè¦šã‚ãŸã€‚",
    firstScene: "çª“ã®å¤–ã€ç©ºãŒæš—ã„ã€‚æ•å…ƒã®ã‚¹ãƒãƒ›ã«ä¸Šå¸ã‹ã‚‰ã®LINEãŒ1ä»¶ã€‚ã¾ã èª­ã‚“ã§ã„ãªã„ã€‚ã‚­ãƒƒãƒãƒ³ã‹ã‚‰ã‚³ãƒ¼ãƒ’ãƒ¼ãƒ¡ãƒ¼ã‚«ãƒ¼ã®ã‚¿ã‚¤ãƒãƒ¼ãŒé³´ã‚‹éŸ³ã€‚æ™‚è¨ˆã¯6:05ã€‚\n\nã©ã†ã™ã‚‹ï¼Ÿ",
  },
  {
    id: "cat_escape", title: "çŒ«ã®è„±èµ°", genre: "æ—¥å¸¸",
    setting: "æ—¥æ›œã®æœ10æ™‚ã€‚é£¼ã„çŒ«ã®ãƒ ã‚®ãŒã„ãªã„ã€‚çª“ãŒå°‘ã—é–‹ã„ã¦ã„ã‚‹ã€‚ä»Šæ—¥ã®åˆå¾Œã€ãƒ ã‚®ã‚’å‹•ç‰©ç—…é™¢ã«é€£ã‚Œã¦è¡Œãäºˆç´„ãŒã‚ã‚‹ã€‚ãƒ ã‚®ã¯ç—…é™¢ãŒå¤§å«Œã„ã ã€‚",
    firstScene: "ãƒªãƒ“ãƒ³ã‚°ã«ã‚‚ã‚­ãƒƒãƒãƒ³ã«ã‚‚ãƒ ã‚®ã®å§¿ãŒãªã„ã€‚çª“ã¯5cmã»ã©é–‹ã„ã¦ã„ã‚‹ã€‚ãƒ†ãƒ¼ãƒ–ãƒ«ã®ä¸Šã«å‹•ç‰©ç—…é™¢ã®è¨ºå¯Ÿåˆ¸ã€‚ç„é–¢ã®é´ç®±ã®ãã°ã«ã€å°ã•ãªæ³¥ã®è¶³è·¡ãŒç‚¹ã€…ã¨ç¶šã„ã¦ã„ã‚‹ã€‚\n\nã©ã†ã™ã‚‹ï¼Ÿ",
  },
  {
    id: "asteroid", title: "72æ™‚é–“", genre: "å£®å¤§",
    setting: "ã‚ãªãŸã¯å›½é€£ã®å±æ©Ÿç®¡ç†å®˜ã€‚å°æƒ‘æ˜ŸãŒ72æ™‚é–“å¾Œã«åœ°çƒã«è¡çªã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã¨ã„ã†å ±å‘ŠãŒå±Šã„ãŸã€‚ã ãŒæƒ…å ±æºã®NASAè·å“¡ã¯ã€3å¹´å‰ã«èª¤å ±ã‚’å‡ºã—ã¦ä¿¡é ¼ã‚’å¤±ã£ãŸäººç‰©ã ã€‚",
    firstScene: "æ·±å¤œ2æ™‚ã€é›»è©±ã§å©ãèµ·ã“ã•ã‚ŒãŸã€‚å£°ã®ä¸»ã¯ã‚¸ã‚§ãƒ¼ãƒ ã‚ºãƒ»ã‚«ãƒ¼ã‚¿ãƒ¼åšå£«ã€‚ã€Œç›´å¾„200mã®å°æƒ‘æ˜Ÿã€72æ™‚é–“å¾Œã«æœ€æ¥è¿‘ã€‚è¡çªç¢ºç‡12%ã€‚ã¾ã å…¬è¡¨ã—ã¦ã„ã¾ã›ã‚“ã€‚ã€å—è©±å™¨ã®å‘ã“ã†ã§ã€åšå£«ã®å‘¼å¸ãŒè’ã„ã€‚ãƒ‡ã‚¹ã‚¯ã®ä¸Šã«ã¯ã€å…ˆé€±ã®å®‰å…¨ä¿éšœä¼šè­°ã®è³‡æ–™ãŒæ•£ã‚‰ã°ã£ã¦ã„ã‚‹ã€‚\n\nã©ã†ã™ã‚‹ï¼Ÿ",
  },
];

const SYS = `ã‚ãªãŸã¯ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ã‚¹ãƒˆãƒ¼ãƒªãƒ¼ã®ã‚²ãƒ¼ãƒ ãƒã‚¹ã‚¿ãƒ¼ã§ã™ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è‡ªç”±ãªè¡Œå‹•å®£è¨€ã«å¿œã˜ã¦ç‰©èªã‚’é€²ã‚ã¦ãã ã•ã„ã€‚

å¿…ãšä»¥ä¸‹ã®JSONå½¢å¼ã®ã¿ã§è¿”ç­”ã—ã¦ãã ã•ã„ã€‚JSONä»¥å¤–ã¯ä¸€åˆ‡å‡ºåŠ›ã—ãªã„ã§ãã ã•ã„ã€‚
çµµæ–‡å­—ã‚„ç‰¹æ®Šè¨˜å·ã¯ä½¿ã‚ãšã€é€šå¸¸ã®æ—¥æœ¬èªãƒ†ã‚­ã‚¹ãƒˆã®ã¿ã§è¨˜è¿°ã—ã¦ãã ã•ã„ã€‚
{"narrative":"æ¬¡ã®å ´é¢ã®æå†™","situation":"ä»Šã®çŠ¶æ³ã‚’1æ–‡ã§è¦ç´„","sceneNumber":1,"isEnding":false,"endingTitle":"","endingSummary":""}

# å ´é¢æå†™ã®ãƒ«ãƒ¼ãƒ«
- narrativeã¯2ã€œ3æ–‡ã€‚çŸ­ãã¦ã‚‚å¯†åº¦ã®é«˜ã„æå†™
- æ–‡ä½“ã¯ä¹¾ã„ãŸãƒˆãƒ¼ãƒ³ã§ã€‚æ¯”å–©ã‚’1ã¤å…¥ã‚Œã‚‹ã“ã¨ã€‚æ„Ÿæƒ…ã‚’ç›´æ¥æ›¸ã‹ãšã€å‹•ä½œã‚„é¢¨æ™¯ã§è¡¨ç¾ã™ã‚‹
- ã‚»ãƒªãƒ•ã¯å®Ÿéš›ã«äººãŒè¨€ã„ãã†ãªã€å°‘ã—ä¸å®Œå…¨ã§ç”Ÿã€…ã—ã„æ—¥æœ¬èªã§æ›¸ãã€‚ä¸å¯§ã™ããªã„
- å ´é¢ã«ã¯å¿…ãš2ã€œ3å€‹ã®å…·ä½“çš„ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ»äººç‰©ãƒ»éŸ³ãƒ»åŒ‚ã„ãªã©ã‚’å«ã‚ã‚‹ã“ã¨
- narrativeã®æœ€å¾Œã¯ã€ç›®ã®å‰ã®å…·ä½“çš„ãªçŠ¶æ³ã«å¯¾ã™ã‚‹å•ã„ã‹ã‘ã§çµ‚ãˆã‚‹ï¼ˆisEnding=trueã®å ´åˆã¯ä¸è¦ï¼‰
- å•ã„ã‹ã‘ã¯ã€Œä»Šã™ãå–ã‚Œã‚‹å…·ä½“çš„ãªè¡Œå‹•ã€ã‚’ä¿ƒã™ã‚‚ã®ã«ã™ã‚‹ã€‚ä¾‹ï¼šã€Œä¸Šå¸ã®LINEã«ã©ã†è¿”ã™ï¼Ÿã€ã€Œå‚˜ã‚’æŒã£ã¦ã„ãã‹ï¼Ÿã€
- ã€Œä»Šæ—¥ä¸€æ—¥ã‚’ã©ã†ä¹—ã‚Šåˆ‡ã‚‹ï¼Ÿã€ã€Œã©ã‚“ãªæ±ºæ–­ã‚’ä¸‹ã™ï¼Ÿã€ã®ã‚ˆã†ãªæŠ½è±¡çš„ãƒ»ä¿¯ç°çš„ãªå•ã„ã‹ã‘ã¯çµ¶å¯¾ã«ç¦æ­¢

# ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›ã®è§£é‡ˆ
- çœŸé¢ç›®ãªå›ç­”: ãã®ã¾ã¾åæ˜ 
- æ›–æ˜§ãƒ»çŸ­ã„å›ç­”: è¿·ã£ãŸæå†™ã«ã—ã¦é€²ã‚ã‚‹
- ãµã–ã‘ãŸå›ç­”: ãƒ¦ãƒ¼ãƒ¢ã‚¢ã§å‡¦ç†
- æ„å‘³ä¸æ˜: ã¼ã‚“ã‚„ã‚Šæå†™ã«ã—ã¦æˆ»ã™
- å±é™ºãƒ»æš´åŠ›: æˆåŠŸã•ã›ãªã„ã€‚æ­¢ã‚ã‚‰ã‚Œã‚‹ç­‰ã§å›é¿
- ç¾å®Ÿé›¢ã‚Œ: æƒ³åƒã ã‘ã®æå†™ã«ã—ã¦ç¾å®Ÿã«æˆ»ã™

# ç‰©èªã®æ§‹é€ 
- ç·Šå¼µã¨ç·©å’Œã®æ³¢ã€‚ãƒˆãƒ©ãƒ–ãƒ«é€£ç¶šç¦æ­¢ã€‚ã†ã¾ãã„ãå ´é¢ã‚‚å…¥ã‚Œã‚‹
- scene 3ã‚ãŸã‚Šã§äºˆæƒ³å¤–ã®å±•é–‹ã‚’å…¥ã‚Œã‚‹
- scene 3ã€œ5ã«ã‚¸ãƒ¬ãƒ³ãƒã‚’å…¥ã‚Œã‚‹
- è‰¯ã„çµæœã®å ´é¢ã‚’æœ€ä½1å›å…¥ã‚Œã‚‹

# åæŸã¨çµæœ«
- sceneNumberã¯1ã‹ã‚‰æ¯å›+1
- scene 5ã‹ã‚‰åæŸã€‚scene 7ã€œ8ã§isEnding=trueã€‚8è¶…ãˆç¦æ­¢
- çµæœ«ãƒˆãƒ¼ãƒ³ã¯å¤šæ§˜ã«ï¼ˆæ„Ÿå‹•/ã»ã£ã“ã‚Š/æ•™è¨“/çˆ½å¿«/åˆ‡ãªã„/ãƒ¦ãƒ¼ãƒ¢ã‚¢ï¼‰
- endingSummaryã¯3ã€œ4æ–‡ï¼šæŒ¯ã‚Šè¿”ã‚Šã€åˆ¤æ–­å‚¾å‘åˆ†æã€æ¬¡å›ãƒ’ãƒ³ãƒˆ`;

const tf = { fontFamily: "'Playfair Display','Noto Serif JP',serif" };
const mf = { fontFamily: "'DM Mono',monospace" };

function App() {
  const [apiKey, setApiKey] = useState(localStorage.getItem("bs2_key") || "");
  const [keyInput, setKeyInput] = useState("");
  const [phase, setPhase] = useState(apiKey ? "title" : "setup");
  const [scenario, setScenario] = useState(SCENARIOS[0]);
  const [scenes, setScenes] = useState([]);
  const [userInput, setUserInput] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [history, setHistory] = useState([]);
  const [ending, setEnding] = useState(null);
  const [actionLog, setActionLog] = useState([]);
  const [isListening, setIsListening] = useState(false);
  const [fadeIn, setFadeIn] = useState(true);
  const [viewH, setViewH] = useState(window.innerHeight);
  const inputRef = useRef(null);
  const scrollRef = useRef(null);
  const recRef = useRef(null);
  const submittingRef = useRef(false);

  const fade = () => { setFadeIn(false); requestAnimationFrame(() => requestAnimationFrame(() => setFadeIn(true))); };

  // Fix #4: Track viewport height for keyboard
  useEffect(() => {
    const onResize = () => {
      const vh = window.visualViewport ? window.visualViewport.height : window.innerHeight;
      setViewH(vh);
    };
    if (window.visualViewport) {
      window.visualViewport.addEventListener("resize", onResize);
      window.visualViewport.addEventListener("scroll", onResize);
    } else {
      window.addEventListener("resize", onResize);
    }
    onResize();
    return () => {
      if (window.visualViewport) {
        window.visualViewport.removeEventListener("resize", onResize);
        window.visualViewport.removeEventListener("scroll", onResize);
      } else {
        window.removeEventListener("resize", onResize);
      }
    };
  }, []);

  // Fix Safari auto-scroll on textarea focus
  useEffect(() => {
    if (!inputRef.current) return;
    const el = inputRef.current;
    const preventScroll = () => {
      requestAnimationFrame(() => {
        window.scrollTo(0, 0);
        document.body.scrollTop = 0;
        document.documentElement.scrollTop = 0;
      });
    };
    el.addEventListener("focus", preventScroll);
    return () => el.removeEventListener("focus", preventScroll);
  }, [phase]);

  useEffect(() => {
    if (scrollRef.current && scenes.length > 0) {
      const els = scrollRef.current.children;
      if (els.length > 0) els[els.length - 1].scrollIntoView({ behavior: "smooth", block: "start" });
    }
  }, [scenes, isLoading]);

  const saveKey = () => {
    if (!keyInput.trim()) return;
    localStorage.setItem("bs2_key", keyInput.trim());
    setApiKey(keyInput.trim());
    setPhase("title");
  };

  // Fix #2: Properly release microphone
  const killMic = useCallback(() => {
    if (recRef.current) {
      try { recRef.current.abort(); } catch(e) {}
      try { recRef.current.stop(); } catch(e) {}
      recRef.current.onresult = null;
      recRef.current.onerror = null;
      recRef.current.onend = null;
      recRef.current = null;
    }
    setIsListening(false);
  }, []);

  const startListening = () => {
    if (isLoading || submittingRef.current) return;
    killMic();
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SR) { setUserInput("ï¼ˆéŸ³å£°å…¥åŠ›éå¯¾å¿œï¼‰"); return; }
    try {
      const r = new SR();
      r.lang = "ja-JP"; r.interimResults = true; r.continuous = false;
      recRef.current = r;
      r.onresult = (e) => {
        const t = Array.from(e.results).map(x => x[0].transcript).join("");
        setUserInput(t);
        // Fix #1: Use submittingRef to prevent double submit
        if (e.results[e.results.length - 1].isFinal) {
          killMic();
          if (!submittingRef.current) {
            submittingRef.current = true;
            setTimeout(() => doSubmit(t), 150);
          }
        }
      };
      r.onerror = (e) => {
        killMic();
        if (e.error !== "aborted") {
          setUserInput(e.error === "not-allowed" ? "ï¼ˆãƒã‚¤ã‚¯ã‚’è¨±å¯ã—ã¦ãã ã•ã„ï¼‰" : "ï¼ˆéŸ³å£°ã‚¨ãƒ©ãƒ¼: " + e.error + "ï¼‰");
        }
      };
      r.onend = () => { setIsListening(false); };
      r.start(); setIsListening(true);
    } catch (err) { setUserInput("ï¼ˆéŸ³å£°ã‚¨ãƒ©ãƒ¼: " + err.message + "ï¼‰"); }
  };

  const startGame = (i) => {
    killMic();
    const s = SCENARIOS[i];
    setScenario(s);
    setScenes([{ type: "scene", text: s.firstScene, sceneNumber: 0 }]);
    setHistory([
      { role: "user", content: "ã‚¹ãƒˆãƒ¼ãƒªãƒ¼è¨­å®šï¼šã€Œ" + s.title + "ã€\n" + s.setting + "\n\næœ€åˆã®å ´é¢ï¼š\n" + s.firstScene + "\n\nsceneNumber=1ã‹ã‚‰é–‹å§‹ã€‚äº†è§£ã¨ã ã‘ç­”ãˆã¦ã€‚" },
      { role: "assistant", content: "äº†è§£" }
    ]);
    setActionLog([]); setEnding(null); submittingRef.current = false; fade(); setPhase("playing");
  };

  const doSubmit = async (text) => {
    if (!text || isLoading) { submittingRef.current = false; return; }
    killMic();
    setUserInput("");
    setScenes(p => [...p, { type: "action", text }]);
    setActionLog(p => [...p, text]);
    setIsLoading(true);

    const nh = [...history, { role: "user", content: text }];
    const th = nh.length <= 14 ? nh : [...nh.slice(0, 2), ...nh.slice(-12)];

    try {
      const res = await fetch("/api/chat", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ apiKey: apiKey, system: SYS, messages: th })
      });

      if (!res.ok) {
        let errMsg = "HTTP " + res.status;
        try { const t = await res.text(); errMsg += ": " + t.slice(0, 200); } catch(e) {}
        throw new Error(errMsg);
      }

      const data = await res.json();
      const raw = data.content.map(c => c.type === "text" ? c.text : "").filter(Boolean).join("\n");

      let p;
      try {
        // Fix #3: Strip non-BMP characters (emoji etc) that cause rendering issues
        const cleaned = raw.replace(/```json\s*/g, "").replace(/```/g, "").trim();
        p = JSON.parse(cleaned);
        if (p.narrative) p.narrative = p.narrative.replace(/[\uD800-\uDFFF]./g, "").replace(/.[\uD800-\uDFFF]/g, "");
        if (p.situation) p.situation = p.situation.replace(/[\uD800-\uDFFF]./g, "").replace(/.[\uD800-\uDFFF]/g, "");
      } catch {
        p = { narrative: raw || "...", situation: "", sceneNumber: scenes.filter(s => s.type === "scene").length + 1, isEnding: false };
      }

      setScenes(prev => [...prev, { type: "scene", text: p.narrative, sceneNumber: p.sceneNumber, situation: p.situation }]);
      setHistory([...nh, { role: "assistant", content: JSON.stringify(p) }]);
      if (p.isEnding) setEnding({ title: p.endingTitle || "çµæœ«", summary: p.endingSummary || "" });
    } catch (err) {
      setScenes(prev => [...prev, { type: "scene", text: "ï¼ˆã‚¨ãƒ©ãƒ¼: " + err.message + "ï¼‰", sceneNumber: -1 }]);
    }
    setIsLoading(false);
    submittingRef.current = false;
  };

  // Fix #1: Prevent double submit from button press during voice
  const submitAction = () => {
    if (!userInput.trim() || isLoading || submittingRef.current) return;
    submittingRef.current = true;
    killMic();
    doSubmit(userInput.trim());
  };

  const onKey = (e) => {
    if (e.key === "Enter" && !e.shiftKey && !e.nativeEvent.isComposing) {
      e.preventDefault();
      submitAction();
    }
  };

  const ctr = {
    height: viewH,
    background: "linear-gradient(180deg,#0d0d1a 0%,#141428 50%,#0d0d1a 100%)",
    display: "flex", justifyContent: "center", alignItems: "flex-start",
    padding: "12px 12px 0", overflow: "hidden",
  };

  const card = {
    width: "100%", maxWidth: 480, height: "100%",
    background: "linear-gradient(165deg,#181830 0%,#12122a 100%)",
    borderRadius: "24px 24px 0 0", border: "1px solid #2a2a44", borderBottom: "none",
    boxShadow: "0 20px 60px #00000066",
    padding: "20px 18px 0",
    opacity: fadeIn ? 1 : 0, transform: fadeIn ? "translateY(0)" : "translateY(12px)",
    transition: "opacity 0.4s,transform 0.4s",
    display: "flex", flexDirection: "column", overflow: "hidden",
  };

  return (
    <div style={ctr}>
      <div style={card}>

        {/* SETUP */}
        {phase === "setup" && (
          <div style={{ textAlign: "center", animation: "slideUp 0.6s ease", overflowY: "auto", flex: 1, paddingBottom: 20 }}>
            <div style={{ ...mf, fontSize: 11, color: "#64dfdf", letterSpacing: 4, marginBottom: 16 }}>STILLNOVA STUDIO</div>
            <h1 style={{ ...tf, fontSize: 32, color: "#e8e8f0", marginBottom: 24 }}>Brain Story 2sec</h1>
            <div style={{ background: "#1a1a2e", borderRadius: 16, padding: 20, border: "1px solid #2a2a42", textAlign: "left" }}>
              <div style={{ ...mf, fontSize: 11, color: "#64dfdf", marginBottom: 10 }}>API KEY</div>
              <p style={{ fontSize: 12, color: "#6a6a7a", lineHeight: 1.7, marginBottom: 12 }}>
                Claude APIã‚­ãƒ¼ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚ã‚­ãƒ¼ã¯ã“ã®ç«¯æœ«ã®ã¿ã«ä¿å­˜ã•ã‚Œã¾ã™ã€‚
              </p>
              <input
                type="password" value={keyInput} onChange={e => setKeyInput(e.target.value)}
                placeholder="sk-ant-..."
                style={{ width: "100%", padding: "12px 16px", background: "#12122a", border: "1.5px solid #2a2a42", borderRadius: 12, color: "#d4d4e0", fontSize: 14, marginBottom: 12 }}
              />
              <button onClick={saveKey} style={{ width: "100%", padding: 14, border: "none", borderRadius: 14, background: keyInput.trim() ? "linear-gradient(135deg,#64dfdf,#4ab8b8)" : "#2a2a42", color: keyInput.trim() ? "#0d0d1a" : "#5a5a6a", fontSize: 15, fontWeight: 700, cursor: keyInput.trim() ? "pointer" : "default" }}>
                ã¯ã˜ã‚ã‚‹
              </button>
            </div>
          </div>
        )}

        {/* TITLE */}
        {phase === "title" && (
          <div style={{ textAlign: "center", animation: "slideUp 0.6s ease", overflowY: "auto", flex: 1, paddingBottom: 20 }}>
            <div style={{ ...mf, fontSize: 11, color: "#64dfdf", letterSpacing: 4, marginBottom: 12 }}>STILLNOVA STUDIO</div>
            <h1 style={{ ...tf, fontSize: 36, color: "#e8e8f0", lineHeight: 1.3, marginBottom: 4 }}>Brain Story</h1>
            <div style={{ ...mf, fontSize: 22, color: "#64dfdf", marginBottom: 8, letterSpacing: 2 }}>2<span style={{ fontSize: 14, verticalAlign: "super" }}>sec</span></div>
            <p style={{ fontSize: 13, color: "#7a7a9a", lineHeight: 1.8, marginBottom: 24 }}>ã‚ãªãŸã®è¨€è‘‰ã§ç‰©èªãŒåˆ†å²ã™ã‚‹</p>

            <div style={{ background: "#1a1a2e", borderRadius: 16, padding: "20px 18px", marginBottom: 20, border: "1px solid #2a2a42", textAlign: "left" }}>
              <div style={{ ...mf, fontSize: 12, color: "#64dfdf", marginBottom: 14 }}>SELECT STORY</div>
              {SCENARIOS.map((s, i) => (
                <button key={s.id} onClick={() => startGame(i)} style={{ display: "flex", alignItems: "center", gap: 12, width: "100%", padding: "14px 16px", marginBottom: 8, background: "linear-gradient(135deg,#1e1e32,#22223a)", border: "1.5px solid #3a3a52", borderRadius: 12, cursor: "pointer", textAlign: "left" }}>
                  <span style={{ ...mf, fontSize: 10, color: "#64dfdf88", padding: "3px 8px", background: "#1a1a2e", borderRadius: 6, flexShrink: 0 }}>{s.genre}</span>
                  <div>
                    <div style={{ fontSize: 15, color: "#d4d4e0", fontWeight: 600, marginBottom: 2 }}>{s.title}</div>
                    <div style={{ fontSize: 11, color: "#6a6a7a" }}>{s.setting.slice(0, 40)}...</div>
                  </div>
                </button>
              ))}
            </div>
            <p style={{ fontSize: 11, color: "#4a4a5a" }}>å£°ã§å³ç­” ãƒ» ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ã‚‚OK</p>
            <button onClick={() => { localStorage.removeItem("bs2_key"); setApiKey(""); setPhase("setup"); }} style={{ marginTop: 16, background: "none", border: "none", color: "#3a3a52", fontSize: 11, cursor: "pointer" }}>APIã‚­ãƒ¼ã‚’å¤‰æ›´</button>
          </div>
        )}

        {/* PLAYING */}
        {phase === "playing" && (
          <>
            <div style={{ marginBottom: 10, flexShrink: 0, display: "flex", justifyContent: "space-between", alignItems: "center" }}>
              <span style={{ ...mf, fontSize: 11, color: "#64dfdf", letterSpacing: 3 }}>{scenario.genre} â€” {scenario.title}</span>
              <span style={{ ...mf, fontSize: 11, color: "#5a5a6a" }}>SCENE {scenes.filter(s => s.type === "scene").length}</span>
            </div>

            <div ref={scrollRef} style={{ flex: 1, overflowY: "auto", marginBottom: 10, paddingRight: 4, minHeight: 0 }}>
              {scenes.map((s, i) => (
                <div key={i} style={{ marginBottom: 16, animation: i === scenes.length - 1 ? "slideUp 0.5s ease" : "none" }}>
                  {s.type === "scene" ? (
                    <div>
                      {s.situation && <div style={{ fontSize: 11, color: "#64dfdf88", marginBottom: 6, ...mf }}>{s.situation}</div>}
                      <p style={{ fontSize: 14, color: "#d4d4e0", lineHeight: 2, whiteSpace: "pre-wrap" }}>{s.text}</p>
                    </div>
                  ) : (
                    <div style={{ padding: "10px 16px", marginLeft: 24, background: "linear-gradient(135deg,#64dfdf12,#64dfdf08)", border: "1px solid #64dfdf33", borderRadius: 12 }}>
                      <span style={{ fontSize: 11, color: "#64dfdf88", ...mf }}>ã‚ãªãŸï¼š</span>
                      <p style={{ fontSize: 14, color: "#e8e8f0", lineHeight: 1.7, marginTop: 4 }}>{s.text}</p>
                    </div>
                  )}
                </div>
              ))}
              {isLoading && (
                <div style={{ padding: "12px 0", display: "flex", alignItems: "center", gap: 8 }}>
                  <div style={{ display: "flex", gap: 4 }}>
                    {[0,1,2].map(i => <div key={i} style={{ width: 6, height: 6, borderRadius: "50%", background: "#64dfdf", animation: `breathe 1.2s ${i*0.3}s infinite` }} />)}
                  </div>
                  <span style={{ fontSize: 12, color: "#5a5a6a" }}>ç‰©èªãŒå±•é–‹ä¸­...</span>
                </div>
              )}
            </div>

            {!ending ? (
              <div style={{ flexShrink: 0, paddingBottom: 8 }}>
                <div style={{ display: "flex", gap: 8, alignItems: "flex-end" }}>
                  <button
                    onClick={isListening ? killMic : startListening}
                    disabled={isLoading || submittingRef.current}
                    style={{ width: 48, height: 48, border: "none", borderRadius: 14, background: isListening ? "linear-gradient(135deg,#ff4757,#ff6b6b)" : "linear-gradient(135deg,#2a2a42,#1e1e32)", color: isListening ? "#fff" : "#8a8a9a", fontSize: 20, cursor: isLoading ? "default" : "pointer", flexShrink: 0, display: "flex", alignItems: "center", justifyContent: "center", opacity: isLoading ? 0.4 : 1, animation: isListening ? "pulse 1s infinite" : "none" }}
                  >
                    ğŸ¤
                  </button>
                  <textarea
                    ref={inputRef} value={userInput} onChange={e => setUserInput(e.target.value)} onKeyDown={onKey}
                    placeholder={isListening ? "èãå–ã‚Šä¸­..." : "è¡Œå‹•ã‚’å…¥åŠ› or ğŸ¤ã§å£°å…¥åŠ›"}
                    disabled={isLoading} rows={1}
                    style={{ flex: 1, padding: "12px 16px", background: "#1a1a2e", border: isListening ? "1.5px solid #ff475766" : "1.5px solid #2a2a42", borderRadius: 14, color: "#d4d4e0", fontSize: 14, resize: "none", lineHeight: 1.5, opacity: isLoading ? 0.4 : 1 }}
                  />
                  <button
                    onClick={submitAction}
                    disabled={!userInput.trim() || isLoading || submittingRef.current}
                    style={{ padding: "12px 18px", border: "none", borderRadius: 14, background: userInput.trim() && !isLoading ? "linear-gradient(135deg,#64dfdf,#4ab8b8)" : "#2a2a42", color: userInput.trim() && !isLoading ? "#0d0d1a" : "#5a5a6a", fontSize: 14, fontWeight: 700, cursor: userInput.trim() && !isLoading ? "pointer" : "default", flexShrink: 0, height: 44 }}
                  >â†’</button>
                </div>
              </div>
            ) : (
              <div style={{ flexShrink: 0, animation: "slideUp 0.5s ease", paddingBottom: 8 }}>
                <div style={{ background: "#1a1a2e", borderRadius: 16, padding: 18, border: "1px solid #64dfdf33", marginBottom: 12 }}>
                  <div style={{ ...mf, fontSize: 10, color: "#64dfdf", letterSpacing: 3, marginBottom: 8 }}>ENDING</div>
                  <div style={{ ...tf, fontSize: 20, color: "#e8e8f0", marginBottom: 10, lineHeight: 1.4 }}>{ending.title}</div>
                  <p style={{ fontSize: 13, color: "#a0a0b0", lineHeight: 1.8 }}>{ending.summary}</p>
                </div>
                <div style={{ display: "flex", gap: 8 }}>
                  <button onClick={() => { killMic(); fade(); setPhase("ending"); }} style={{ flex: 1, padding: 14, border: "none", borderRadius: 14, background: "linear-gradient(135deg,#64dfdf,#4ab8b8)", color: "#0d0d1a", fontSize: 14, fontWeight: 700, cursor: "pointer" }}>æŒ¯ã‚Šè¿”ã‚Šã‚’è¦‹ã‚‹</button>
                  <button onClick={() => { killMic(); fade(); setPhase("title"); }} style={{ flex: 1, padding: 14, border: "1.5px solid #3a3a52", borderRadius: 14, background: "transparent", color: "#8a8a9a", fontSize: 14, cursor: "pointer" }}>åˆ¥ã®ç‰©èªã¸</button>
                </div>
              </div>
            )}
          </>
        )}

        {/* ENDING */}
        {phase === "ending" && ending && (
          <div style={{ animation: "slideUp 0.6s ease", overflowY: "auto", flex: 1, paddingBottom: 20 }}>
            <div style={{ ...mf, fontSize: 11, color: "#64dfdf", letterSpacing: 3, marginBottom: 24, textAlign: "center" }}>ENDING</div>
            <div style={{ ...tf, fontSize: 28, color: "#e8e8f0", marginBottom: 20, lineHeight: 1.4, textAlign: "center" }}>{ending.title}</div>
            <p style={{ fontSize: 15, color: "#a0a0b0", lineHeight: 2, marginBottom: 20, textAlign: "left" }}>{ending.summary}</p>

            <div style={{ background: "#1a1a2e", borderRadius: 16, padding: 18, marginBottom: 16, border: "1px solid #2a2a42", textAlign: "left", maxHeight: 400, overflowY: "auto" }}>
              <div style={{ ...mf, fontSize: 11, color: "#64dfdf", letterSpacing: 2, marginBottom: 14 }}>FULL STORY</div>
              <p style={{ fontSize: 13, color: "#8a8a9a", lineHeight: 1.9, marginBottom: 12, whiteSpace: "pre-wrap" }}>{scenario.firstScene}</p>
              {scenes.slice(1).map((s, i) => (
                <div key={i} style={{ marginBottom: 12 }}>
                  {s.type === "action" ? (
                    <div style={{ padding: "8px 12px", marginLeft: 16, background: "#64dfdf08", border: "1px solid #64dfdf22", borderRadius: 10 }}>
                      <span style={{ fontSize: 11, color: "#64dfdf88", ...mf }}>â–¸ </span>
                      <span style={{ fontSize: 13, color: "#c4c4d0" }}>{s.text}</span>
                    </div>
                  ) : (
                    <p style={{ fontSize: 13, color: "#8a8a9a", lineHeight: 1.9, whiteSpace: "pre-wrap" }}>{s.text}</p>
                  )}
                </div>
              ))}
            </div>

            <div style={{ background: "#1a1a2e", borderRadius: 16, padding: 18, marginBottom: 24, border: "1px solid #2a2a42", textAlign: "left" }}>
              <div style={{ ...mf, fontSize: 11, color: "#ffd166", letterSpacing: 2, marginBottom: 12 }}>YOUR ACTIONS</div>
              {actionLog.map((a, i) => (
                <div key={i} style={{ display: "flex", gap: 10, padding: "8px 0", borderBottom: i < actionLog.length - 1 ? "1px solid #22223a" : "none" }}>
                  <span style={{ ...mf, fontSize: 11, color: "#5a5a6a", width: 20, flexShrink: 0 }}>{i + 1}</span>
                  <span style={{ fontSize: 13, color: "#a0a0b0", lineHeight: 1.6 }}>{a}</span>
                </div>
              ))}
            </div>

            <button onClick={() => { fade(); setPhase("title"); }} style={{ width: "100%", padding: 16, border: "none", borderRadius: 14, background: "linear-gradient(135deg,#64dfdf,#4ab8b8)", color: "#0d0d1a", fontSize: 16, fontWeight: 700, cursor: "pointer", letterSpacing: 1, marginBottom: 8 }}>åˆ¥ã®ã‚¹ãƒˆãƒ¼ãƒªãƒ¼ã‚’è©¦ã™</button>
            <p style={{ fontSize: 11, color: "#5a5a6a", textAlign: "center" }}>åŒã˜ã‚¹ãƒˆãƒ¼ãƒªãƒ¼ã§ã‚‚ã€é•ã†è¡Œå‹•ã§é•ã†çµæœ«ã«ãªã‚Šã¾ã™</p>
          </div>
        )}

      </div>
    </div>
  );
}

ReactDOM.createRoot(document.getElementById("root")).render(<App />);
</script>
</body>
</html>
